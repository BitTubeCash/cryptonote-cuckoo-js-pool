14d13
< var crypto = require('crypto');
16a16
> var notifications = require('./notifications.js');
19c19
< var cuHashing = require('cuckarood29v-hashing');
---
> var cuHashing = require('cryptonight-hashing');
35a36,43
> // Set Cuckaroo29 algorithm
> var cnAlgorithm = config.cnAlgorithm || "cuckaroo29s";
> var cnVariant = config.cnVariant || 0;
> var cnBlobType = config.cnBlobType || 7;
> 
> var currentBlockHash = "";
> var currentBlockHeight = 0;
> 
37c45
< var instanceId = crypto.randomBytes(4);
---
> var instanceId = utils.instanceId();
42a51,55
> // Pool settings
> var shareTrustEnabled = config.poolServer.shareTrust && config.poolServer.shareTrust.enabled;
> var shareTrustStepFloat = shareTrustEnabled ? config.poolServer.shareTrust.stepDown / 100 : 0;
> var shareTrustMinFloat = shareTrustEnabled ? config.poolServer.shareTrust.min / 100 : 0;
> 
46a60,73
> var slushMiningEnabled = config.poolServer.slushMining && config.poolServer.slushMining.enabled;
> 
> if (!config.poolServer.paymentId) config.poolServer.paymentId = {};
> if (!config.poolServer.paymentId.addressSeparator) config.poolServer.paymentId.addressSeparator = "+";
> 
> // Set block notification port
> if (config.blockNotifier.port)
> {
> 	var ctrl_server = net.createServer(function (localsocket) {
> 		jobRefresh('ctrlport');
> 	});
> 	ctrl_server.listen(config.blockNotifier.port,'127.0.0.1');
> }
> 
60c87
< net.Socket.prototype.minerId = 'dummy';
---
>  net.Socket.prototype.minerId = 'dummy';
65a93,103
> // Variable difficulty retarget
> setInterval(function(){
> 	var now = Date.now() / 1000 | 0;
> 	for (var minerId in connectedMiners){
> 		var miner = connectedMiners[minerId];
> 		if(!miner.noRetarget) {
> 			miner.retarget(now);
> 		}
> 	}
> }, config.poolServer.varDiff.retargetTime * 1000);
> 
74a113
> 			removeConnectedWorker(miner, 'timeout');
99,101d137
< 		case 'notify': 
< 			jobRefresh(false,null,'notify');
< 			break;
113c149
< 	this.buffer = Buffer.from(this.blob, 'hex');
---
> 	this.buffer = new Buffer(this.blob, 'hex');
115,116d150
< 	this.previous_hash = Buffer.alloc(32);
< 	this.buffer.copy(this.previous_hash, 0, 7, 39);
119,122c153,154
< 	// The clientNonceLocation is the location at which the client pools should set the nonces for each of their clients.
< 	this.clientNonceLocation = this.reserveOffset + 12;
< 	// The clientPoolLocation is for multi-thread/multi-server pools to handle the nonce for each of their tiers.
< 	this.clientPoolLocation = this.reserveOffset + 8;
---
> 	this.previous_hash = new Buffer(32);
> 	this.buffer.copy(this.previous_hash,0,7,39);
125d156
< 
128,134c159
< 		return utils.cnUtil.convert_blob(this.buffer, 8).toString('hex');
< 	},
< 	nextBlobWithChildNonce: function(){
< 		// Write a 32 bit integer, big-endian style to the 0 byte of the reserve offset.
< 		this.buffer.writeUInt32BE(++this.extraNonce, this.reserveOffset);
< 		// Don't convert the blob to something hashable.  You bad.
< 		return this.buffer.toString('hex');
---
> 		return utils.cnUtil.convert_blob(this.buffer, cnBlobType).toString('hex');
142,144c167
< 	apiInterfaces.rpcDaemon('getblocktemplate',
< 							{reserve_size: 17, wallet_address: config.poolServer.poolAddress},
< 							callback)
---
> 	apiInterfaces.rpcDaemon('getblocktemplate', {reserve_size: 8, wallet_address: config.poolServer.poolAddress}, callback);
159d181
< 
162,164d183
< 		if(!miner.noRetarget) {
< 			miner.retarget();
< 		}
165a185
> 		miner.pushMessage('message', {'message':'new block at height: '+currentBlockTemplate.height}, minerId);
171a192,194
> function getBlockCount(callback){
> 	apiInterfaces.rpcDaemon('getblockcount', {}, callback);
> }
173,177c196,198
< var ctrl_server = net.createServer(function (localsocket) { 
< 	localsocket.destroy();
< 	process.send({type: 'notify'});
< });
< ctrl_server.listen(config.poolServer.notifyPort,'127.0.0.1');
---
> function getBlockHash(callback){
> 	apiInterfaces.rpcDaemon('on_getblockhash', [currentBlockHeight - 1], callback);
> }
179,189c200,241
< function jobRefresh(loop, callback, caller){
< 	callback = callback || function(){};
< 	getBlockTemplate(function(error, result){
< 		if (loop)
< 			setTimeout(function(){
< 				jobRefresh(true,null,'timeout');
< 			}, config.poolServer.blockRefreshInterval);
< 		if (error){
< 			log('error', logSystem, 'Error polling getblocktemplate %j', [error]);
< 			if (!poolStarted) log('error', logSystem, 'Could not start pool');
< 			callback(false);
---
> function jobLoop()
> {
> 	jobRefresh();
> 	setTimeout(function(){ jobLoop(); }, config.poolServer.blockRefreshInterval);
> }
> 
> var jobRefreshCompleteCallback = null;
> function jobRefreshError(text, error)
> {
> 	log('error', logSystem, text, [error]);
> 	if(jobRefreshCompleteCallback != null)
> 		jobRefreshCompleteCallback(false);
> }
> 
> var jobRefreshCounter = 0;
> 
> function jobRefresh(state){
> 	state = state || "check_force";
> 
> 	switch(state){
> 	case "check_force":
> 		if(jobRefreshCounter % config.poolServer.blockRefreshForce == 0)
> 			jobRefresh("get_template");
> 		else
> 			jobRefresh("check_count");
> 		jobRefreshCounter++;
> 		break;
> 
> 	case "check_count":
> 		getBlockCount(function(error, result){
> 			if (error){
> 				jobRefreshError('Error polling getblockcount %j', error);
> 				return;
> 			}
> 
> 			if(result.count == currentBlockHeight) {
> 				jobRefresh("check_hash");
> 				return;
> 			}
> 
> 			log('info', logSystem, 'Blockchain height changed to %d, updating template.', [currentBlockHeight]);
> 			jobRefresh("get_template");
191c243,244
< 		}
---
> 		});
> 	break;
193,200c246,252
< 		let buffer = Buffer.from(result.blocktemplate_blob, 'hex');
< 		let new_hash = Buffer.alloc(32);
< 		buffer.copy(new_hash, 0, 7, 39);
< 
< 		if (!currentBlockTemplate || result.height != currentBlockTemplate.height) {
< 			for (var minerId in connectedMiners){
< 				var miner = connectedMiners[minerId];
< 				miner.validJobs = [];
---
> 	case "ctrlport":
> 		log('info', logSystem, 'New block notification received from daemon');
> 	case "check_hash":
> 		getBlockHash(function(error, result){
> 			if(error) {
> 				jobRefreshError('Error polling on_getblockhash %j', error);
> 				return;
202,210d253
< 			log('info', logSystem, 'New block to mine at height %d w/ difficulty of %d (bc to %d miners) (trigger: %s)', [result.height, result.difficulty, Object.keys(connectedMiners).length, caller]);
< 			processBlockTemplate(result);
< 		}
< 		if (!poolStarted) {
< 			startPoolServerTcp(function(successful){ poolStarted = true });
< 		}
< 		callback(true);
< 	})
< }
211a255,293
> 			if(result == currentBlockHash) {
> 				if(jobRefreshCompleteCallback != null)
> 					 jobRefreshCompleteCallback(true);
> 				return;
> 			}
> 
> 			log('info', logSystem, 'Blockchain hash changed to %s, updating template.', [currentBlockHash]);
> 			jobRefresh("get_template");
> 			return;
> 		});
> 	break;
> 
> 	case "get_template":
> 		getBlockTemplate(function(error, result){
> 			if(error) {
> 				jobRefreshError('Error polling getblocktemplate %j', error);
> 				return;
> 			}
> 
> 			currentBlockHeight = result.height;
> 			currentBlockHash = result.prev_hash;
> 
> 			var buffer = new Buffer(result.blocktemplate_blob, 'hex');
> 			var previous_hash = new Buffer(32);
> 			buffer.copy(previous_hash,0,7,39);
> 			if (!currentBlockTemplate || previous_hash.toString('hex') != currentBlockTemplate.previous_hash.toString('hex')){
> 				for (var minerId in connectedMiners){
> 					var miner = connectedMiners[minerId];
> 					miner.validJobs = [];
> 				}
> 				log('info', logSystem, 'New block to mine at height %d w/ difficulty of %d', [result.height, result.difficulty]);
> 				processBlockTemplate(result);
> 			}
> 
> 			if(jobRefreshCompleteCallback != null)
> 				jobRefreshCompleteCallback(true);
> 		});
> 	}
> }
244a327,334
> 
> 	if (shareTrustEnabled) {
> 		this.trust = {
> 			threshold: config.poolServer.shareTrust.threshold,
> 			probability: 1,
> 			penalty: 0
> 		};
> 	}
247c337
< 	retarget: function(){
---
> 	retarget: function(now){
249d338
< 		var now = Date.now() / 1000 | 0;
274d362
< 
279a368
> 		this.setNewDiff(newDiff);
281a371,372
> 	},
> 	setNewDiff: function(newDiff){
283,285d373
< 		if(newDiff > currentBlockTemplate.difficulty) {
< 			newDiff=currentBlockTemplate.difficulty;
< 		}
287,288d374
< 		this.pendingDifficulty = newDiff;
< 		this.pushMessage('message', 'Retargetting difficulty '+this.difficulty+' to '+newDiff,this.id);
289a376,378
> 		this.pendingDifficulty = newDiff;
> 		this.pushMessage('getjobtemplate', this.getJob(),this.id);
> 		this.pushMessage('message', {'message':'retarget diff to: '+newDiff},this.id);
301c390
< 		var padded = Buffer.alloc(32);
---
> 		var padded = new Buffer(32);
309c398
< 		var buffReversed = Buffer.from(buffArray);
---
> 		var buffReversed = new Buffer(buffArray);
326a416
> 
348c438
< 			algo: "cuckarood",
---
> 			algo: "cuckaroo",
375a466
> 				removeConnectedWorker(this, 'banned');
431c522
< 
---
> 		
452c543,544
< 			var address = login;
---
> 			var addr = login.split(config.poolServer.paymentId.addressSeparator);
> 			var address = addr[0] || null;
456,461c548
< 				if (params.agent && params.agent.includes('Swap')) {
< 					sendReply({code: -32600, message: "Invalid address used for login"}, null, 'submit');
< 				}
< 				else{
< 					sendReply('Invalid address used for login');
< 				}
---
> 				sendReply({code: -32600, message: "Invalid address used for login"}, null, 'submit');
466c553
< 				if (!addressPrefix) addressPrefix = 'N/A';
---
> 				if (!addressPrefix) {addressPrefix = 'N/A';}
469,474c556
< 				if (params.agent && params.agent.includes('Swap')) {
< 					sendReply({code: -32600, message: "Invalid address used for login"}, null, 'submit');
< 				}
< 				else{
< 					sendReply('Invalid address used for login');
< 				}
---
> 				sendReply({code: -32600, message: "Invalid address used for login"}, null, 'submit');
478,479d559
< 			log('info', logSystem, 'LOGIN '+params.login+' : '+params.pass+' : '+params.agent);
< 
481c561
< 			miner = new Miner(minerId, login, pass, ip, port, params.agent, Buffer.from(workerName).toString('base64'), difficulty, noRetarget, pushMessage);
---
> 			miner = new Miner(minerId, login, pass, ip, port, params.agent, workerName, difficulty, noRetarget, pushMessage);
484c564
< 
---
> 			
491c571
< 				algo: "cuckarood",
---
> 				algo: "cuckaroo",
494a575
> 				height: job.height,
499,500d579
< 		
< 			miner.pushMessage('message', 'Login OK (retarget:'+(noRetarget?'no':'yes')+')',minerId);
502,509c581
< 			break;
< 		case 'getjob':
< 			if (!miner){
< 				sendReply('Unauthenticated');
< 				return;
< 			}
< 			miner.heartbeat();
< 			sendReply(null, miner.getJob());
---
> 			newConnectedWorker(miner);
513c585
< 				sendReply('Unauthenticated');
---
> 				sendReply({code: -32504, message: "Unauthenticated"}, null, 'submit');
521a594,595
> 			job = miner.validJobs[miner.validJobs.length-1];
> 
523,527c597
< 				var dateNow = Date.now();
< 				var dateNowSeconds = Date.now() / 1000 | 0;
< 				redisClient.zadd(config.coin + ':workerHashrate', dateNowSeconds, [miner.difficulty, miner.login+':'+miner.workerName, dateNow,3].join(':'));
< 				log('info', logSystem, 'Invalid job id '+miner.login+':'+miner.workerName);
< 				sendReply(null, 'stale', 'submit');
---
> 				sendReply(null,"stale", 'submit');
530a601
> 
537a609
> 			// Force lowercase for further comparison
543c615
< 				log('info', logSystem, 'Duplicate share: ' + JSON.stringify(params) + ' from ' + minerText);
---
> 				log('warn', logSystem, 'Duplicate share: ' + JSON.stringify(params) + ' from ' + minerText);
557c629
< 				sendReply({code: -32600, message: "pool error"}, null, 'submit');
---
> 				sendReply({code: -32600, message: "Block expired"}, null, 'submit');
563c635,650
< 
---
> 			
> 			if (shareTrustEnabled){
> 				if (shareAccepted){
> 					miner.trust.probability -= shareTrustStepFloat;
> 					if (miner.trust.probability < shareTrustMinFloat)
> 						miner.trust.probability = shareTrustMinFloat;
> 					miner.trust.penalty--;
> 					miner.trust.threshold--;
> 				}
> 				else{
> 					log('warn', logSystem, 'Share trust broken by %s@%s', [miner.login, miner.ip]);
> 					miner.trust.probability = 1;
> 					miner.trust.penalty = config.poolServer.shareTrust.penalty;
> 				}
> 			}
> 			
592a680,731
>  * New connected worker
>  **/
> function newConnectedWorker(miner){
> 	log('info', logSystem, 'Miner connected %s@%s on port', [miner.login, miner.ip, miner.port]);
> 	if (miner.workerName !== 'undefined') log('info', logSystem, 'Worker Name: %s', [miner.workerName]);
> 	if (miner.difficulty) log('info', logSystem, 'Miner difficulty fixed to %s', [miner.difficulty]);
> 
> 	redisClient.sadd(config.coin + ':workers_ip:' + miner.login, miner.ip);
> 	redisClient.hincrby(config.coin + ':ports:'+miner.port, 'users', 1);
> 
> 	redisClient.hincrby(config.coin + ':active_connections', miner.login + '~' + miner.workerName, 1, function(error, connectedWorkers) {
> 		if (connectedWorkers === 1) {
> 			notifications.sendToMiner(miner.login, 'workerConnected', {
> 				'LOGIN' : miner.login,
> 				'MINER': miner.login.substring(0,7)+'...'+miner.login.substring(miner.login.length-7),
> 				'IP': miner.ip.replace('::ffff:', ''),
> 				'PORT': miner.port,
> 				'WORKER_NAME': miner.workerName !== 'undefined' ? miner.workerName : ''
> 			});
> 		}
> 	});
> }
> 
> /**
>  * Remove connected worker
>  **/
> function removeConnectedWorker(miner, reason){
> 	redisClient.hincrby(config.coin + ':ports:'+miner.port, 'users', '-1');
> 
> 	redisClient.hincrby(config.coin + ':active_connections', miner.login + '~' + miner.workerName, -1, function(error, connectedWorkers) {
> 		if (reason === 'banned') {
> 			notifications.sendToMiner(miner.login, 'workerBanned', {
> 				'LOGIN' : miner.login,
> 				'MINER': miner.login.substring(0,7)+'...'+miner.login.substring(miner.login.length-7),
> 				'IP': miner.ip.replace('::ffff:', ''),
> 				'PORT': miner.port,
> 				'WORKER_NAME': miner.workerName !== 'undefined' ? miner.workerName : ''
> 			});
> 		} else if (!connectedWorkers || connectedWorkers <= 0) {
> 			notifications.sendToMiner(miner.login, 'workerTimeout', {
> 				'LOGIN' : miner.login,
> 				'MINER': miner.login.substring(0,7)+'...'+miner.login.substring(miner.login.length-7),
> 				'IP': miner.ip.replace('::ffff:', ''),
> 				'PORT': miner.port,
> 				'WORKER_NAME': miner.workerName !== 'undefined' ? miner.workerName : '',
> 				'LAST_HASH': utils.dateFormat(new Date(miner.lastBeat), 'yyyy-mm-dd HH:MM:ss Z')
> 			});
> 	   }
> 	});
> }
> 
> /**
610a750,752
> /**
>  * Record miner share data
>  **/
612d753
< 
615a757,777
> 	var updateScore;
> 	// Weighting older shares lower than newer ones to prevent pool hopping
> 	if (slushMiningEnabled) {
> 		// We need to do this via an eval script because we need fetching the last block time and
> 		// calculating the score to run in a single transaction (otherwise we could have a race
> 		// condition where a block gets discovered between the time we look up lastBlockFound and
> 		// insert the score, which would give the miner an erroneously huge proportion on the new block)
> 		updateScore = ['eval', `
> 			local age = (ARGV[3] - redis.call('hget', KEYS[2], 'lastBlockFound')) / 1000
> 			local score = string.format('%.17g', ARGV[2] * math.exp(age / ARGV[4]))
> 			redis.call('hincrbyfloat', KEYS[1], ARGV[1], score)
> 			return {score, tostring(age)}
> 			`,
> 			2 /*keys*/, config.coin + ':scores:roundCurrent', config.coin + ':stats',
> 			/* args */ miner.login, job.difficulty, Date.now(), config.poolServer.slushMining.weight];
> 	}
> 	else {
> 		job.score = job.difficulty;
> 		updateScore = ['hincrbyfloat', config.coin + ':scores:roundCurrent', miner.login, job.score]
> 	}
> 
617,621c779,785
< 		['hincrby', config.coin + ':shares:roundCurrent', miner.login, job.difficulty],
< 		['zadd', config.coin + ':workerHashrate', dateNowSeconds, [job.difficulty, miner.login+':'+miner.workerName, dateNow,0].join(':')],
< 		['zadd', config.coin + ':hashrate', dateNowSeconds, [job.difficulty, miner.login, dateNow].join(':')],
< 		['hincrby', config.coin + ':workers:' + miner.login, 'hashes', job.difficulty],
< 		['hset', config.coin + ':workers:' + miner.login, 'lastShare', dateNowSeconds]
---
> 		updateScore,
> 		['hincrby', config.coin + ':shares_actual:roundCurrent', miner.login, job.difficulty],
> 		['zadd', config.coin + ':hashrate', dateNowSeconds, [job.difficulty*32, miner.login, dateNow].join(':')],
> 		['hincrby', config.coin + ':workers:' + miner.login, 'hashes', job.difficulty*32],
> 		['hset', config.coin + ':workers:' + miner.login, 'lastShare', dateNowSeconds],
> 		['expire', config.coin + ':workers:' + miner.login, (86400 * cleanupInterval)],
> 		['expire', config.coin + ':payments:' + miner.login, (86400 * cleanupInterval)]
623a788,794
> 	if (miner.workerName) {
> 		redisCommands.push(['zadd', config.coin + ':hashrate', dateNowSeconds, [job.difficulty*32, miner.login + '~' + miner.workerName, dateNow].join(':')]);
> 		redisCommands.push(['hincrby', config.coin + ':unique_workers:' + miner.login + '~' + miner.workerName, 'hashes', job.difficulty*32]);
> 		redisCommands.push(['hset', config.coin + ':unique_workers:' + miner.login + '~' + miner.workerName, 'lastShare', dateNowSeconds]);
> 		redisCommands.push(['expire', config.coin + ':unique_workers:' + miner.login + '~' + miner.workerName, (86400 * cleanupInterval)]);
> 	}
> 	
626,627c797,800
< 		redisCommands.push(['rename', config.coin + ':shares:roundCurrent', config.coin + ':shares:round' + job.height]);
< 		redisCommands.push(['hgetall', config.coin + ':shares:round' + job.height]);
---
> 		redisCommands.push(['rename', config.coin + ':scores:roundCurrent', config.coin + ':scores:round' + job.height]);
> 		redisCommands.push(['rename', config.coin + ':shares_actual:roundCurrent', config.coin + ':shares_actual:round' + job.height]);
> 		redisCommands.push(['hgetall', config.coin + ':scores:round' + job.height]);
> 		redisCommands.push(['hgetall', config.coin + ':shares_actual:round' + job.height]);
634a808,814
> 
> 		if (slushMiningEnabled) {
> 			job.score = parseFloat(replies[0][0]);
> 			var age = parseFloat(replies[0][1]);
> 			log('info', logSystem, 'Submitted score ' + job.score + ' for difficulty ' + job.difficulty + ' and round age ' + age + 's');
> 		}
> 
635a816
> 			var workerScores = replies[replies.length - 2];
636a818,820
> 			var totalScore = Object.keys(workerScores).reduce(function(p, c){
> 				return p + parseFloat(workerScores[c])
> 			}, 0);
638c822
< 				return p + parseInt(workerShares[c]);
---
> 				return p + parseInt(workerShares[c])
645c829
< 				null,null,0
---
> 				totalScore
650a835,842
> 
> 			notifications.sendToAll('blockFound', {
> 				'HEIGHT': job.height,
> 				'HASH': hashHex,
> 				'DIFFICULTY': blockTemplate.difficulty,
> 				'SHARES': totalShares,
> 				'MINER': miner.login.substring(0,7)+'...'+miner.login.substring(miner.login.length-7)
> 			});
656d847
< 
665c856
< 	var template = Buffer.alloc(blockTemplate.buffer.length);
---
> 	var template = new Buffer(blockTemplate.buffer.length);
668a860
> 	
671,675d862
< 
< 
< 	if(!params.pow || params.pow.length != 32)
< 		return;
< 
678,682c865,869
< 	shareBuffer = utils.cnUtil.construct_block_blob(template, bignum(nonce,10).toBuffer({endian : 'little',size : 4}),8,params.pow);
< 
< 	var header =  Buffer.concat([utils.cnUtil.convert_blob(shareBuffer,8),bignum(nonce,10).toBuffer({endian : 'big',size : 4})]);
< 	var prooferror = cuHashing.cuckarood29v(header,params.pow);
< 
---
> 	shareBuffer = utils.cnUtil.construct_block_blob(template, bignum(nonce,10).toBuffer({endian : 'little',size : 4}),cnBlobType,params.pow);
> 	
> 	var header =  Buffer.concat([utils.cnUtil.convert_blob(shareBuffer,cnBlobType),bignum(nonce,10).toBuffer({endian : 'big',size : 4})]);
> 	prooferror = cuHashing.cuckaroo29s(header,params.pow);
> 		
684,685c871
< 		log('warn', logSystem, JSON.stringify(params));
< 		log('warn', logSystem, prooferror);
---
> 
690,692c876,878
< 	   if(params.pow) hash=cuHashing.cycle_hash(params.pow);
< 	   shareType = 'valid';
< 	   hashDiff = bignum(jobdiff);
---
> 		hash=cuHashing.cycle_hash(params.pow);
> 		shareType = 'valid';
> 		hashDiff = bignum(jobdiff);
703c889
< 				var blockFastHash = utils.cnUtil.get_block_id(shareBuffer, 8).toString('hex');
---
> 				var blockFastHash = utils.cnUtil.get_block_id(shareBuffer, cnBlobType).toString('hex');
705,706c891,892
< 					'Block %s found at height %d by miner %s@%s',
< 					[blockFastHash.substr(0, 6), job.height, miner.login, miner.ip]
---
> 					'Block %s found at height %d by miner %s@%s - submit result: %j',
> 					[blockFastHash.substr(0, 6), job.height, miner.login, miner.ip, result]
709c895
< 				jobRefresh(false,null,'block');
---
> 				jobRefresh();
730a917,918
> 	log('info', logSystem, 'Clear values for connected workers in redis database.');
> 	redisClient.del(config.coin + ':active_connections');
733a922
> 
735c924
< 				log('warn', logSystem, 'Miner RPC request missing RPC id '+JSON.stringify(jsonData));
---
> 				log('warn', logSystem, 'Miner RPC request missing RPC id');
739,746c928
< 				log('warn', logSystem, 'Miner RPC request missing RPC method '+JSON.stringify(jsonData));
< 				return;
< 			}
< 			else if (jsonData.id && jsonData.id === "Stratum") {
< 				// play nice with GGM
< 			}
< 			else if (!jsonData.params) {
< 				log('warn', logSystem, 'Miner RPC request missing RPC params '+JSON.stringify(jsonData));
---
> 				log('warn', logSystem, 'Miner RPC request missing RPC method');
758d939
< 
770,771c951
< 			};
< 
---
> 			};              
780c960
< 				if(!jsonData.params && jsonData.method && jsonData.method === "getjobtemplate") return; // GGM quirq
---
> 				if(!jsonData.params && jsonData.method && jsonData.method === "getjobtemplate") return;
853a1034,1075
> 		if (portData.ssl) {
> 			if (!config.poolServer.sslCert) {
> 				log('error', logSystem, 'Could not start server listening on port %d (SSL): SSL certificate not configured', [portData.port]);
> 				cback(true);
> 			} else if (!config.poolServer.sslKey) {
> 				log('error', logSystem, 'Could not start server listening on port %d (SSL): SSL key not configured', [portData.port]);
> 				cback(true);
> 			} else if (!config.poolServer.sslCA) {
> 				log('error', logSystem, 'Could not start server listening on port %d (SSL): SSL certificate authority not configured', [portData.port]);
> 				cback(true);
> 			} else if (!fs.existsSync(config.poolServer.sslCert)) {
> 				log('error', logSystem, 'Could not start server listening on port %d (SSL): SSL certificate file not found (configuration error)', [portData.port]);
> 				cback(true);
> 			} else if (!fs.existsSync(config.poolServer.sslKey)) {
> 				log('error', logSystem, 'Could not start server listening on port %d (SSL): SSL key file not found (configuration error)', [portData.port]);
> 				cback(true);
> 			} else if (!fs.existsSync(config.poolServer.sslCA)) {
> 				log('error', logSystem, 'Could not start server listening on port %d (SSL): SSL certificate authority file not found (configuration error)', [portData.port]);
> 				cback(true);
> 			} else {
> 				var options = {
> 					key: fs.readFileSync(config.poolServer.sslKey),
> 					cert: fs.readFileSync(config.poolServer.sslCert),
> 					ca: fs.readFileSync(config.poolServer.sslCA)
> 				};
> 				tls.createServer(options, socketResponder).listen(portData.port, function (error, result) {
> 					if (error) {
> 						log('error', logSystem, 'Could not start server listening on port %d (SSL), error: $j', [portData.port, error]);
> 						cback(true);
> 						return;
> 					}
> 
> 					log('info', logSystem, 'Clear values for SSL port %d in redis database.', [portData.port]);
> 					redisClient.del(config.coin + ':ports:'+portData.port);
> 					redisClient.hset(config.coin + ':ports:'+portData.port, 'port', portData.port);
> 
> 					log('info', logSystem, 'Started server listening on port %d (SSL)', [portData.port]);
> 					cback();
> 				});
> 			}
> 		}
> 		else {
860a1083,1086
> 				log('info', logSystem, 'Clear values for port %d in redis database.', [portData.port]);
> 				redisClient.del(config.coin + ':ports:'+portData.port);
> 				redisClient.hset(config.coin + ':ports:'+portData.port, 'port', portData.port);
> 
863a1090
> 		}
877c1104,1113
< 	jobRefresh(true, function(sucessful){ },'initial');
---
> 	jobRefreshCompleteCallback = function(sucessful){
> 		if (!sucessful){
> 			log('error', logSystem, 'Could not start pool');
> 			return;
> 		}
> 		startPoolServerTcp(function(successful){ });
> 		jobRefreshCompleteCallback = null;
> 	};
> 
> 	jobLoop();
